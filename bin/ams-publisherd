#!/usr/bin/env python

from argo_nagios_ams_publisher.config import parse_config
from argo_nagios_ams_publisher.log import Logger
from argo_nagios_ams_publisher.run import init_dirq_consume
from argo_nagios_ams_publisher.shared import Shared

from datetime import datetime

import argparse
import daemon
import errno
import multiprocessing
import os
import psutil
import pwd
import signal
import sys

"""
    try first to import el6 modulefile, if that fails try to import el7
    modulefile
"""
try:
    import daemon.pidlockfile as pidlockfile
except ImportError:
    import daemon.pidfile as pidlockfile

pidfile = '/var/run/argo-nagios-ams-publisher/pid'
logfile = '/var/log/argo-nagios-ams-publisher/ams-publisher.log'

shared = None
logger = None

def get_userids(user):
    return pwd.getpwnam(user)[2], pwd.getpwnam(user)[3]

def daemon_start(context_daemon, restart=False):
    global shared
    confopts = parse_config(shared.log)
    shared = Shared(confopts=confopts)

    if context_daemon.pidfile.is_locked() and not \
            context_daemon.pidfile.i_am_locking():
        pid = context_daemon.pidfile.read_pid()
        try:
            psutil.Process(pid=pid)
            shared.log.info('Already running (%s)' % pid)
            return 0
        except psutil.NoSuchProcess:
            context_daemon.pidfile.break_lock()

    def sigtermhandle(signum, frame):
        shared.event('term').set()

    def sigusrhandle(signum, frame):
        shared.event('usr1').set()

    context_daemon.signal_map = {
        signal.SIGTERM: sigtermhandle,
        signal.SIGUSR1: sigusrhandle
    }

    uid, gid = get_userids(shared.general['runasuser'])
    context_daemon.uid = uid
    context_daemon.gid = gid
    os.chown(shared.log.fileloghandle.name, uid, gid)
    context_daemon.files_preserve = [shared.log.fileloghandle]

    if not restart:
        shared.log.info('Started')

    context_daemon.open()
    with context_daemon:
        init_dirq_consume(shared.workers, daemonized=True)

def daemon_stop(context_daemon, restart=False):
    if context_daemon.pidfile.is_locked():
        pid = context_daemon.pidfile.read_pid()

        try:
            process = psutil.Process(pid=pid)
        except psutil.NoSuchProcess:
            context_daemon.pidfile.break_lock()
            if not restart:
                shared.log.info('Not running - cleaning stale pidfile')
        else:
            process.terminate()
            pgone, palive = psutil.wait_procs([process])

            if not restart:
                shared.log.info('Stopping (%s)' % pid)

            for p in palive:
                p.kill()

    elif not restart:
        shared.log.info('Not running')

    return 0

def daemon_status(context_daemon):
    if context_daemon.pidfile.is_locked() and not \
            context_daemon.pidfile.i_am_locking():
        pid = context_daemon.pidfile.read_pid()

        try:
            p = psutil.Process(pid=pid)
            p.send_signal(signal.SIGUSR1)
        except psutil.NoSuchProcess:
            shared.log.info('Not running - stale pidfile')
            return 1
        else:
            shared.log.info('Running (%s)' % pid)
            return 0
    else:
        shared.log.info('Not running')
        return 3

def pidfiledir(pidfile):
    try:
        if not os.path.exists(os.path.dirname(pidfile)):
            dirp = os.path.dirname(pidfile)
            os.makedirs(dirp)
            uid, gid = get_userids(shared.general['runasuser'])
            os.chown(dirp, uid, gid)
    except (OSError, IOError) as e:
        if e.args[0] != errno.EEXIST:
            shared.log.error('%s %s' % (os.strerror(e.args[0]), e.args[1]))
            raise SystemExit(1)

def daemonizer(args):
    """
       Create DaemonContext for setting the behaviour and the options for
       process once it becomes the daemon.

    """
    pidfiledir(pidfile)

    context_daemon = daemon.DaemonContext()
    context_daemon.pidfile = pidlockfile.PIDLockFile(pidfile, threaded=False)

    if args.daemon == 'start':
        daemon_start(context_daemon)

    elif args.daemon == 'stop':
        ret = daemon_stop(context_daemon)
        raise SystemExit(ret)

    elif args.daemon == 'restart':
        daemon_stop(context_daemon, restart=True)
        daemon_start(context_daemon, restart=True)

    elif args.daemon == 'status':
        ret = daemon_status(context_daemon)
        raise SystemExit(ret)

def main():
    """
       Function fetch arguments from command line, initialize logger,
       initialize singleton object that will hold configuration options,
       register SIGTERM and SIGUSR handlers and starts daemonizing the process.
       There is also option for no-daemonizing mainly for debugging purposes.

    """
    lobj = Logger(sys.argv[0], logfile)
    logger = lobj.get()

    global shared
    shared = Shared()

    shared.add_log(logger)
    shared.add_event('term', multiprocessing.Event())
    shared.add_event('usr1', multiprocessing.Event())

    parser = argparse.ArgumentParser(prog='ams-publisherd')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-n', dest='nofork', action='store_true',
                        help='do not fork into background')
    group.add_argument('-d', dest='daemon', type=str,
                       help='daemon arguments: start, stop, restart, status', metavar='')
    args = parser.parse_args()

    if args.nofork:
        try:
            confopts = parse_config()
            shared = Shared(confopts=confopts)
            init_dirq_consume(shared.workers, daemonized=False)
        except KeyboardInterrupt:
            raise SystemExit(1)

    elif args.daemon:
        daemonizer(args)

main()
